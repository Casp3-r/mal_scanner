import os
import re
import json
import base64
import time
import requests
from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse
from django.contrib import messages
from django.contrib.auth import authenticate, login
from django.contrib.auth.models import User, Group, Permission
from django.core.mail import send_mail
from django.urls import reverse
from django.views.decorators.csrf import csrf_protect
from dotenv import load_dotenv
from itsdangerous import URLSafeTimedSerializer, SignatureExpired
from django.conf import settings
from django.contrib.auth import logout
from django.contrib.auth.decorators import login_required
from .models import Item
from django.contrib import messages

# Load environment variables
load_dotenv()
env_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), '.env')
load_dotenv(dotenv_path=env_path)

# VirusTotal API Key
VIRUSTOTAL_API_KEY = os.getenv("VIRUSTOTAL_API_KEY")

# Serializer for generating tokens
serializer = URLSafeTimedSerializer(settings.SECRET_KEY)

# Create user groups and assign permissions
def create_user_groups():
    # Create groups
    admin_group, created = Group.objects.get_or_create(name='Admin')
    viewer_group, created = Group.objects.get_or_create(name='Viewer')

    # Check and assign permissions
    try:
        manage_permission = Permission.objects.get(codename='can_manage_content')
        view_permission = Permission.objects.get(codename='can_view_content')

        admin_group.permissions.add(manage_permission, view_permission)
        viewer_group.permissions.add(view_permission)
    except Permission.DoesNotExist:
        print("One or more permissions do not exist.")

# Call this function in your app's ready method or shell
create_user_groups()

def index(request):
    if request.user.is_authenticated:
        # Check if the user is in the Admin group
        if request.user.groups.filter(name='Admin').exists():
            return redirect('admin_dashboard')  # Redirect to the admin dashboard
        else:
            return render(request, 'index.html')  # Render the main page for regular users
    return redirect('register')  # Redirect to the registration page if not authenticated

@csrf_protect
def user_login(request):
    if request.user.is_authenticated:
        # Check if the user is in the Admin group
        if request.user.groups.filter(name='Admin').exists():
            return redirect('admin_dashboard')  # Redirect to the admin dashboard
        else:
            return render(request, 'index.html')  # Render the main page for regular users

    if request.method == 'POST':
        username = request.POST.get('username').strip()
        password = request.POST.get('password').strip()

        # Authenticate the user
        user = authenticate(request, username=username, password=password)
        if user is not None:  # If authentication is successful
            login(request, user)  # Log the user in

            # Check if the user is an admin
            if username == 'admin':  # Replace 'admin' with the actual admin username
                return redirect('admin_dashboard')  # Redirect to the admin dashboard
            else:
                return redirect('index')  # Redirect to the index for regular users
        else:
            messages.error(request, "Invalid username or password")
            return render(request, 'login.html')

    return render(request, 'login.html')

def register(request):
    if request.user.is_authenticated:
        # Check if the user is in the Admin group
        if request.user.groups.filter(name='Admin').exists():
            return redirect('admin_dashboard')  # Redirect to the admin dashboard
        else:
            return render(request, 'index.html')  # Render the main page for regular users

    if request.method == 'POST':
        first_name = request.POST.get('first_name', '').strip()
        last_name = request.POST.get('last_name', '').strip()
        username = request.POST.get('username', '').strip()
        email = request.POST.get('email', '').strip()
        password = request.POST.get('password', '').strip()

        # Check if username or email already exists
        if User.objects.filter(username=username).exists():
            messages.error(request, "Username is already taken")
            return render(request, 'register.html')

        if User.objects.filter(email=email).exists():
            messages.error(request, "Email is already registered")
            return render(request, 'register.html')

        try:
            # Create the user
            user = User.objects.create_user(username=username, email=email, password=password)
            user.first_name = first_name
            user.last_name = last_name
            user.save()
            if username == 'admin':  # Change this condition as needed
                admin_group = Group.objects.get(name='Admin')
                user.groups.add(admin_group)
            messages.success(request, "Registration successful! Please log in.")
            return redirect('login')  # Redirect to the login page
        except Exception as e:
            messages.error(request, f"An error occurred during registration: {str(e)}")
            return render(request, 'register.html')

    return render(request, 'register.html')

@csrf_protect
def reset_password(request):
    if request.method == 'POST':
        email = request.POST.get('email')

        # Check if the email exists in the User model
        try:
            user = User.objects.get(email=email)
            user_id = user.id

            # Generate a password reset token
            token = serializer.dumps(email, salt='password-reset-salt')

            # Generate the reset link with absolute URL
            reset_link = request.build_absolute_uri(
                reverse('reset_password_token', kwargs={'user_id': user_id, 'token': token})
            )

            # Send password reset email
            try:
                send_mail(
                    subject='Password Reset Request',
                    message=f'Click the link to reset your password: {reset_link}',
                    from_email=settings.EMAIL_HOST_USER,
                    recipient_list=[email],
                )
                messages.success(request, 'Password reset email sent! Check your inbox.')
            except Exception as e:
                messages.error(request, f'Error sending email: {e}')
        except User.DoesNotExist:
            messages.error(request, 'No account found with that email address.')

        return redirect('login')  # Redirect to login after processing

    return render(request, 'reset_password.html')

@csrf_protect
def reset_password_token(request, user_id, token):
    try:
        email = serializer.loads(token, salt='password-reset-salt', max_age=3600)  # Token valid for 1 hour
    except SignatureExpired:
        messages.error(request, 'The reset link has expired.')
        return redirect('reset_password')

    if request.method == 'POST':
        new_password = request.POST.get('new_password')
        confirm_password = request.POST.get('confirm_password')

        if new_password != confirm_password:
            messages.error(request, 'Passwords do not match. Please try again.')
            return redirect('reset_password_token', user_id=user_id, token=token)

        try:
            user = User.objects.get(id=user_id)
            user.set_password(new_password)  # Use set_password to hash the password
            user.save()

            messages.success(request, 'Your password has been updated successfully.')
            return redirect('login')
        except User.DoesNotExist:
            messages.error(request, 'User  not found.')
            return redirect('reset_password')

    return render(request, 'reset_password_token.html')  # Render the form to enter new password

@login_required
def admin_dashboard(request):
    if not request.user.groups.filter(name='Admin').exists():
        return redirect('login')

    users = User.objects.all()  # Fetch all users from the database
    return render(request, 'admin_dashboard.html', {'users': users})

@login_required
def create_user(request):
    if not request.user.groups.filter(name='Admin').exists():
        return redirect('login')

    if request.method == 'POST':
        username = request.POST.get('username')
        email = request.POST.get('email')
        password = request.POST.get('password')
        user = User(username=username, email=email)
        user.set_password(password)  # Hash the password
        user.save()
        messages.success(request, "User  created successfully.")
        return redirect('admin_dashboard')

    return render(request, 'create_user.html')


@login_required
def update_user(request, user_id):
    if not request.user.groups.filter(name='Admin').exists():
        return redirect('login')

    user = get_object_or_404(User, id=user_id)

    if request.method == 'POST':
        user.username = request.POST.get('username')
        user.email = request.POST.get('email')
        password = request.POST.get('password')
        if password:  # Only update password if provided
            user.set_password(password)
        user.save()
        messages.success(request, "User  updated successfully.")
        return redirect('admin_dashboard')

    return render(request, 'update_user.html', {'user': user})

@login_required
def delete_user(request, user_id):
    if not request.user.groups.filter(name='Admin').exists():
        return redirect('login')

    user = get_object_or_404(User, id=user_id)

    if request.method == 'POST':
        user.delete()
        messages.success(request, "User  deleted successfully.")
        return redirect('admin_dashboard')

    return render(request, 'delete_user.html', {'user': user})

def user_logout(request):
    logout(request)  # Log the user out
    messages.success(request, 'You have been logged out successfully.')  # Optional: Add a success message
    return redirect('login')  # Redirect to the registration page or any other page

def handle_file_upload(request):
    uploaded_file = request.FILES.get('file')
    if not uploaded_file:
        return JsonResponse({'error': 'No file uploaded'}, status=400)

    if uploaded_file.size > 10 * 1024 * 1024:  # 10 MB limit
        return JsonResponse({'error': 'File size exceeds 10 MB limit'}, status=400)

    file_path = os.path.join(settings.MEDIA_ROOT, uploaded_file.name)
    try:
        with open(file_path, 'wb') as f:
            for chunk in uploaded_file.chunks():
                f.write(chunk)
    except IOError as e:
        return JsonResponse({'error': f'Error saving file: {str(e)}'}, status=500)

    scan_response = scan_file_with_virustotal(file_path)

    # Clean up the uploaded file
    try:
        os.remove(file_path)
    except OSError as e:
        print(f"Error deleting file: {e}")

    return JsonResponse(scan_response)

def handle_url_scan(request):
    url_to_scan = request.POST.get('url')
    if not url_to_scan:
        return JsonResponse({'error': 'No URL provided'}, status=400)

    if not url_to_scan.startswith(('http://', 'https://')):
        return JsonResponse({'error': 'Invalid URL format. Must start with http:// or https://'}, status=400)

    scan_response = scan_url_with_virustotal(url_to_scan)
    return JsonResponse(scan_response)

def handle_search(request):
    query = request.POST.get('query')
    if not query:
        return JsonResponse({'error': 'No search query provided'}, status=400)

    query_type = determine_query_type(query)
    if query_type is None:
        return JsonResponse({'error': 'Invalid query. Must be a hash, IP address, domain, or URL.'}, status=400)

    search_response = search_virustotal_api(query, query_type)
    return JsonResponse(search_response)

def scan_file_with_virustotal(file_path):
    try:
        url = "https://www.virustotal.com/api/v3/files"
        headers = {"x-apikey": VIRUSTOTAL_API_KEY}

        with open(file_path, 'rb') as file:
            upload_response = requests.post(url, headers=headers, files={'file': file})

        if upload_response.status_code == 200:
            upload_data = upload_response.json()
            scan_id = upload_data.get('data', {}).get('id', 'Unknown')

            # Fetch detailed analysis
            details_url = f"https://www.virustotal.com/api/v3/analyses/{scan_id}"
            details_response = requests.get(details_url, headers=headers)

            if details_response.status_code == 200:
                analysis_data = details_response.json()
                scan_results = analysis_data.get('data', {}).get('attributes', {}).get('results', {})

                # Parse malicious details
                malicious_segments = []
                for engine, result in scan_results.items():
                    if result.get('category') == 'malicious':
                        malicious_segments.append({
                            'engine': engine,
                            'result': result.get('result'),
                            'details': result.get('details', 'No details available'),  # Safely handle missing 'details'
                        })

                return {
                    'message': 'File analysis completed',
                    'scan_id': scan_id,
                    'malicious_segments': malicious_segments,
                }

            return handle_virustotal_error(details_response)

        return handle_virustotal_error(upload_response)

    except requests.exceptions.RequestException as e:
        return {'error': 'Network error during VirusTotal request', 'details': str(e)}

def scan_url_with_virustotal(url_to_scan):
    try:
        api_url = "https://www.virustotal.com/api/v3/urls"
        headers = {"x-apikey": VIRUSTOTAL_API_KEY}

        # Encode the URL in base64 format for the API
        encoded_url = base64.urlsafe_b64encode(url_to_scan.encode('utf-8')).decode('utf-8').strip("=")

               # Submit the URL to VirusTotal
        response = requests.post(f"{api_url}/{encoded_url}", headers=headers)

        if response.status_code == 200:
            data = response.json()

            # Extract submission ID
            scan_id = data.get('data', {}).get('id', 'Unknown')
            submission_date = data.get('data', {}).get('attributes', {}).get('date', 'Unknown')

            # Fetch detailed insights
            details_url = f"https://www.virustotal.com/api/v3/analyses/{scan_id}"
            details_response = requests.get(details_url, headers=headers)

            if details_response.status_code == 200:
                details_data = details_response.json()
                scan_results = details_data.get('data', {}).get('attributes', {}).get('results', {})

                # Parse malicious details
                malicious_segments = []
                for engine, result in scan_results.items():
                    if result.get('category') == 'malicious':
                        malicious_segments.append({
                            'engine': engine,
                            'result': result.get('result'),
                            'details': result.get('details', 'No details available'),  # Safely handle missing 'details'
                        })

                return {
                    'message': 'URL analysis completed',
                    'scan_id': scan_id,
                    'submission_date': submission_date,
                    'malicious_segments': malicious_segments,
                }

            return handle_virustotal_error(details_response)

        return handle_virustotal_error(response)

    except requests.exceptions.RequestException as e:
        return {'error': 'Network error during VirusTotal request', 'details': str(e)}

def handle_virustotal_error(response):
    try:
        error_data = response.json()
        return {
            'error': 'VirusTotal API error',
            'status_code': response.status_code,
            'message': error_data.get('error', {}).get('message', 'Unknown error')
        }
    except Exception:
        return {
            'error': 'Unknown error',
            'status_code': response.status_code,
            'message': response.text
        }

def search_virustotal_api(query, query_type):
    try:
        endpoints = {
            'hash': f"https://www.virustotal.com/api/v3/files/{query}",
            'ip_address': f"https://www.virustotal.com/api/v3/ip_addresses/{query}",
            'domain': f"https://www.virustotal.com/api/v3/domains/{query}",
            'url': f"https://www.virustotal.com/api/v3/urls/{requests.utils.quote(query, safe='')}",
        }

        url = endpoints.get(query_type)
        if not url:
            return {'error': 'Invalid query type'}, 400

        headers = {"x-apikey": VIRUSTOTAL_API_KEY}
        response = requests.get(url, headers=headers)

        if response.status_code == 200:
            data = response.json()
            return {'message': 'Query successful', 'data': data}, 200
        
        return handle_virustotal_error(response)

    except requests.exceptions.RequestException as e:
        return {'error': 'Network error during VirusTotal request', 'details': str(e)}, 500

def determine_query_type(query):
    """Determines the query type (hash, IP address, domain, or URL)."""
    if re.match(r'^[a-fA-F0-9]{32}$|^[a-fA-F0-9]{40}$|^[a-fA-F0-9]{64}$', query):
        return 'hash'
    elif re.match(r'^\d{1,3}(\.\d{1,3}){3}$', query):
        return 'ip_address'
    elif re.match(r'^([a-zA-Z0-9-]{1,63}\.){1,}[a-zA-Z]{2,}$', query):
        return 'domain'
    elif query.startswith(('http://', 'https://')):
        return 'url'
    return None

def display_results(request):
    # Example data for demonstration purposes
    malicious_segments = [
        {
            'engine': 'Engine1',
            'result': 'malware_detected',
            'details': {
                'suspicious_links': ['http://bad.example.com'],
                'code_snippets': ['<script>malicious_code()</script>']
            }
        },
        {
            'engine': 'Engine2',
            'result': 'phishing_detected',
            'details': None
        }
    ]
    return JsonResponse({'malicious_segments': malicious_segments})

